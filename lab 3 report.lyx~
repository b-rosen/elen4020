#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass IEEEtran
\begin_preamble
% for subfigures/subtables
\usepackage[caption=false,font=footnotesize]{subfig}
\end_preamble
\options journal
\use_default_options false
\maintain_unincluded_children false
\language british
\language_package none
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command bibtex
\index_command default
\float_placement H
\paperfontsize 11
\spacing single
\use_hyperref true
\pdf_title "Your Title"
\pdf_author "Your Name"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle false
\pdf_quoted_options "pdfpagelayout=OneColumn, pdfnewwindow=true, pdfstartview=XYZ, plainpages=false"
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 0
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 0
\use_package mhchem 1
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 2
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
onecolumn
\end_layout

\end_inset


\end_layout

\begin_layout Title
Lab 3 Report
\end_layout

\begin_layout Author
Shane House (749524), Benjamin Rosen (858324)
\end_layout

\begin_layout Special Paper Notice
School of Electrical & Information Engineering, University of the Witwatersrand,
 Private Bag 3, 2050, Johannesburg, South Africa
\end_layout

\begin_layout Section
Introduction
\begin_inset CommandInset label
LatexCommand label
name "sec:Introduction"

\end_inset


\end_layout

\begin_layout Standard
The purpose of this lab was to learn to use map reduce frameworks to create
 two algorithms that perform matrix multiplication.
 Once the algorithms were created one was to be used to find nodes connected
 by length 3 in an unweighted directed graph which is represented as a matrix.
 The Python library Mrjob was selected to implement the algorithms.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Algorithms"

\end_inset

 below discusses the created algorithms and how they were implemented.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Node-Graph"

\end_inset

 details how the node graph problem was solved, while Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Results"

\end_inset

 gives the results of testing the algorithms and finally, Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Conclusions"

\end_inset

 concludes the report.
 
\end_layout

\begin_layout Section
Algorithms
\begin_inset CommandInset label
LatexCommand label
name "sec:Algorithms"

\end_inset


\end_layout

\begin_layout Subsection
Algorithm A
\end_layout

\begin_layout Standard
This algorithm has 2 stages.
 In the first map stage, the script reads in each element of the two matrices
 and returns the columns of the first matrix or the rows of the second matrix
 as the key and the position, value and matrix number as the value.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
smallskip
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the second stage, the algorithm returns the final positions in the output
 matrix as the key and the multiplied values as the value.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
smallskip
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The reduce stage then adds all the mapped values together and prints out
 the position and value of each element in the output matrix.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
For matrices A(i,j) and B(j,k)
\end_layout

\begin_layout Plain Layout
In the map phase:
\end_layout

\begin_layout Plain Layout
if matrix A
\end_layout

\begin_layout Plain Layout
\begin_inset space \quad{}
\end_inset

yield key(j) value(row,column,value,1)
\end_layout

\begin_layout Plain Layout
else
\end_layout

\begin_layout Plain Layout
\begin_inset space \quad{}
\end_inset

yield key(j) value(row,column,value,2)
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
medskip
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
in the second stage:
\end_layout

\begin_layout Plain Layout
create array matrix1 a fill it using values whose last element is 1
\end_layout

\begin_layout Plain Layout
create array matrix2 and fill it using values whose last element is 2
\end_layout

\begin_layout Plain Layout
for each entry i in matrix1
\end_layout

\begin_layout Plain Layout
\begin_inset space \quad{}
\end_inset

for each entry j in matrix2 
\end_layout

\begin_layout Plain Layout
\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset

yield key(i[row],j[column]) value(i[value]*j[value])
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
bigskip
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In reduce stage:
\end_layout

\begin_layout Plain Layout
yield key[0] key[1] sum(values)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Pseudo code for Algorithm A 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Algorithm B
\end_layout

\begin_layout Standard
In the mapping phase of this algorithm, the script reads in each element
 of the two input matrices and constructs a 2D array representation of them.
 It then groups the row and column needed to construct each element of the
 output matrix and yields them to be used in the reduction phase.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
smallskip
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The reduction phase takes the above mentioned groups and multiplies the
 necessary values together and then adds the answers to get the final value
 for each element.
 It then prints the position and value to the output file.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
For matrices A(i,j) and B(j,k)
\end_layout

\begin_layout Plain Layout
In the map phase:
\end_layout

\begin_layout Plain Layout
for each column k in B
\end_layout

\begin_layout Plain Layout
\begin_inset space \quad{}
\end_inset

for each row i in A 
\end_layout

\begin_layout Plain Layout
\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset

for each column j in A
\end_layout

\begin_layout Plain Layout
\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset

yield key(i,k) value(A(i,j))
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
medskip
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
for each row i in A
\end_layout

\begin_layout Plain Layout
\begin_inset space \quad{}
\end_inset

for each row j in B 
\end_layout

\begin_layout Plain Layout
\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset

for each column k in B
\end_layout

\begin_layout Plain Layout
\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset


\begin_inset space \quad{}
\end_inset

yield key(i,k) value(B(i,j))
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
bigskip
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In reduce stage:
\end_layout

\begin_layout Plain Layout
for each column j in A
\end_layout

\begin_layout Plain Layout
\begin_inset space \quad{}
\end_inset

temp = values[j]*values[num_of_cols_in_A+j]
\end_layout

\begin_layout Plain Layout
\begin_inset space \quad{}
\end_inset

sum += temp
\end_layout

\begin_layout Plain Layout
yield key[0] key[1] sum
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Pseudo code for Algorithm B 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Node Graph
\begin_inset CommandInset label
LatexCommand label
name "sec:Node-Graph"

\end_inset


\end_layout

\begin_layout Standard
In order for this problem to be solved, first the node graph must be represented
 as a matrix.
 This is achieved by allotting each row to a node (1-N nodes).
 The same is done for the columns.
 A connection between nodes is represented as a number in the position 
\shape italic
(i, j), 
\shape default
where 
\shape italic
i 
\shape default
and 
\shape italic
j
\shape default
 are the indices for the nodes that are connected.
 Since, for this lab, the graph is unweighted, the value of each position
 is either a 1 (if they are connected) or 0 (if they are unconnected).
 The fact that the lab specifies a directed graph implies that a filled
 position
\shape italic
 (i, j) 
\shape default
(i.e.
 that 
\shape italic
i 
\shape default
has a connection pointing to 
\shape italic
j
\shape default
) does not imply the converse 
\shape italic
(j, i)
\shape default
.
\end_layout

\begin_layout Standard
After this is done algorithm a can be used 3 times in succession to perform
 matrix multiplication of the matrix with itself to find the nodes that
 are of length 3, the number of these connections can then be mapped in
 the mapping phase of a map reduce framework and the reduce phase will count
 the number of times this occurs.
 This uses the fact that for a matrix 
\shape italic
A
\shape default
, representing a graph G, 
\begin_inset Formula $A^{k}$
\end_inset

 will yield the number of connections between nodes that have a length 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\begin_layout Section
Results
\begin_inset CommandInset label
LatexCommand label
name "sec:Results"

\end_inset


\end_layout

\begin_layout Standard
Although algorithm B has only one stage and algorithm A has two stages,
 algorithm A was found to preform much better for large matrices.
\end_layout

\begin_layout Section
Conclusions
\begin_inset CommandInset label
LatexCommand label
name "sec:Conclusions"

\end_inset


\end_layout

\begin_layout Standard
The map reduce framework can be used to solve matrix multiplication in one
 or two stages.
 Although the one stage algorithm out preforms the two stage algorithm for
 small matrices, the two stage algorithm is significantly faster for 2 sage
 algorithms.
 The created algorithms can also be used to solve node graph lengths when
 the node graph is represented as a matrix.
 
\end_layout

\end_body
\end_document
